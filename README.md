# Using Different Calling Conventions Inside The Same Rust Project

A calling convention specifies for example how parameters gets passed 
between functions on a specific architecture and a specific
runtime system (e.g. firmware or operating system). This is necessary on the one 
hand that code generated by one compiler can fulfill its work but also that code 
generated by different compilers or different object files 
(e.g older version or other compiler) can be linked together.

There are two major calling conventions. The **System V ABI** and the Microsoft
PE calling convention (*"Microsoft/PE"*). I'm not 100% sure about the official name of the latter.
These calling conventions can be related to an executable format but this is not 
a requirement. Due to my knowledge, and I'm not 100% into this,
ELF can support different ABIs and this information is stored in the header,
whereas the PE format, the default executable format for Microsoft Windows and 
UEFI firmware, only supports the Microsoft/PE calling convention.

The System V ABI is used on UNIX systems, therefore every Linux or MacOS 
machine (at least Intel Macs). It's hard to find good references. MacOS
follows System V ABI perhaps by convention, but I can't find an official document.

Let's take the following function: `add(a: i64, b: i64) -> i64` on `x86_64`.
Without smart scalar compiler optimizations, this would result in a machine 
code that gets two arguments passed, moves one of the parameters into the/one 
accumulator register and then add the other value to it.

| Parameter | Register (System V ABI) | Register (Microsoft/PE) |
|-----------|-------------------------|-------------------------|
| a         | rdi                     | rcx                     |
| b         | rsi                     | rdx                     |
| (return)  | rax                     | rax                     |

What's cool about Rust is that it is relatively easy for us to specify
the calling convention that should be used. For this, please look
into the code and execute it with `cargo run`. The code shows
all relevant parts with comments.~~~~

***THIS PROJECT ONLY BUILDS ON UNIX SYSTEMS WITH GCC FOR NOW BECAUSE IT 
   USES GNU ASSEMBLER (GAS)***
